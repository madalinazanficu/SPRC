/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "oauth.h"
#include<string>
#include<iostream>
#include<fstream>
#include<sstream>
#include<vector>
#include "helpers_client.h"

std::unordered_map<std::string, bool> user_refresh;


char *string_to_char(std::string str) {
	char *cstr = (char *)calloc(str.length() + 1, sizeof(char));
	strcpy(cstr, str.c_str());
	return cstr;
}

struct tokken create_empty_token() {
	struct tokken new_token;
	new_token.approved = 0;
	new_token.type = "Empty token";
	new_token.value = "";
	new_token.ttl = 0;
	return new_token;
}


// TODO: get client output from here
std::string request_autorization_fun(CLIENT *clnt, std::string user_id, struct tokken &auto_token) {
	struct cl_request  request_autorization_1_arg;
	struct ser_response  *result_1;

	request_autorization_1_arg.client_id = string_to_char(user_id);
	request_autorization_1_arg.tokken = create_empty_token();
	request_autorization_1_arg.info = string_to_char("");

	result_1 = request_autorization_1(&request_autorization_1_arg, clnt);
	if (result_1 == (struct ser_response *) NULL) {
		clnt_perror (clnt, "call failed");
	}

	auto_token = result_1->auto_token;
	return result_1->message;
}

// TODO: get client output from here
void request_user_approvall(CLIENT *clnt, std::string user_id,
								struct tokken &auto_token) {


	struct ser_response  *result_2;
	struct cl_request  request_approve_1_arg;

	request_approve_1_arg.client_id = string_to_char(user_id);
	request_approve_1_arg.tokken = auto_token;
	request_approve_1_arg.info = string_to_char("");

	result_2 = request_approve_1(&request_approve_1_arg, clnt);
	if (result_2 == (struct ser_response *) NULL) {
		clnt_perror (clnt, "call failed");
	}

	auto_token = result_2->auto_token;
}

void request_access(CLIENT *clnt, std::string user_id,
						struct tokken auto_token) {
	struct ser_response  *result_3;
	struct cl_request  request_access_token_1_arg;

	request_access_token_1_arg.client_id = "3";
	request_access_token_1_arg.tokken = auto_token;

	// Check if the user has auto_refresh enabled
	if (user_refresh[user_id] == true) {
		request_access_token_1_arg.info = string_to_char("REFRESH");
	} else {
		request_access_token_1_arg.info = string_to_char("");
	}

	result_3 = request_access_token_1(&request_access_token_1_arg, clnt);
	if (result_3 == (struct ser_response *) NULL) {
		clnt_perror (clnt, "call failed");
	}

	printf("Result: %s\n", result_3->message);
	printf("Access token: %s\n", result_3->access_token.value);
	printf("Refresh token: %s\n", result_3->refresh_token.value);
	printf("\n");
}

void validate_delegated_action_fun(CLIENT *clnt) {
	struct ser_response  *result_4;
	struct cl_request  validate_delegated_action_1_arg;

	struct tokken empty_token;
	empty_token.type = "";

	validate_delegated_action_1_arg.client_id = "4";
	validate_delegated_action_1_arg.tokken = empty_token;
	validate_delegated_action_1_arg.info = string_to_char("");

	result_4 = validate_delegated_action_1(&validate_delegated_action_1_arg, clnt);
	if (result_4 == (struct ser_response *) NULL) {
		clnt_perror (clnt, "call failed");
	}

	printf("Result 4: %s\n", result_4->access_token.type);
}

void process_request_cmd(CLIENT *clnt, std::string client_id,
							std::string auto_refresh) {


	// Does the current user have auto_refresh enabled?
	if (auto_refresh == "1") {
		user_refresh[client_id] = true;
	} else {
		user_refresh[client_id] = false;
	}

	// Step1 : request autorization
	struct tokken auto_token = create_empty_token();

	std::string message = request_autorization_fun(clnt, client_id, auto_token);
	if (message == "USER_NOT_FOUND") {
		std::cout << "USER_NOT_FOUND" << std::endl;
		return;
	}

	// Step2 : request user approval
	request_user_approvall(clnt, client_id, auto_token);

	// Step3: request access token and refresh token
	request_access(clnt, client_id, auto_token);

}

void process_other_cmd(CLIENT *clnt, std::string client_id,
						std::string command, std::string resource) {

	std::cout << "Command:" << command << std::endl;
}


int main (int argc, char *argv[])
{
	char *host;
	if (argc < 3) {
		printf ("usage: %s server_host\n", argv[0]);
		exit (1);
	}

	host = argv[1];
	CLIENT *clnt = clnt_create (host, OAUTH_PROG, OAUTH_VERS, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}

	char *client_file;
	client_file = argv[2];

	// Read from client file
	std::ifstream clients(client_file);
	std::string command;
	while(std::getline(clients, command)) {
		std::stringstream ss(command);
		std::vector<std::string> command_parts;
		while(ss.good()) {
			std::string substr;
			std::getline(ss, substr, ',');
			command_parts.push_back(substr);
		}

		if (command_parts[1] == "REQUEST") {
			process_request_cmd(clnt, command_parts[0], command_parts[2]);
		} else {
			process_other_cmd(clnt, command_parts[0], command_parts[1], command_parts[2]);
		}
	}


	// O-Auth scheme
	// request_autorization_fun(clnt);
	// request_access(clnt);
	// request_access(clnt);
	// validate_delegated_action_fun(clnt);

	clnt_destroy (clnt);
	exit (0);
}
