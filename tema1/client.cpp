/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "oauth.h"
#include<string>
#include<iostream>
#include<fstream>
#include<sstream>
#include<vector>
#include "helpers_client.h"

std::unordered_map<std::string, bool> user_refresh;

void request_autorization_fun(CLIENT *clnt) {
	struct cl_request  request_autorization_1_arg;
	struct ser_response  *result_1;

	struct tokken empty_token;
	empty_token.type = "";

	request_autorization_1_arg.client_id = "1";
	request_autorization_1_arg.tokken = empty_token;

	result_1 = request_autorization_1(&request_autorization_1_arg, clnt);
	if (result_1 == (struct ser_response *) NULL) {
		clnt_perror (clnt, "call failed");
	}

	printf("Result 1: %s\n", result_1->access_token.type);
}

void request_user_approvall(CLIENT *clnt) {
	struct ser_response  *result_2;
	struct cl_request  request_approve_1_arg;

	struct tokken empty_token;
	empty_token.type = "";

	request_approve_1_arg.client_id = "2";
	request_approve_1_arg.tokken = empty_token;

	result_2 = request_approve_1(&request_approve_1_arg, clnt);
	if (result_2 == (struct ser_response *) NULL) {
		clnt_perror (clnt, "call failed");
	}

	printf("Result 2: %s\n", result_2->access_token.type);
}

void request_access(CLIENT *clnt) {
	struct ser_response  *result_3;
	struct cl_request  request_access_token_1_arg;

	struct tokken empty_token;
	empty_token.type = "";

	request_access_token_1_arg.client_id = "3";
	request_access_token_1_arg.tokken = empty_token;

	result_3 = request_access_token_1(&request_access_token_1_arg, clnt);
	if (result_3 == (struct ser_response *) NULL) {
		clnt_perror (clnt, "call failed");
	}

	printf("Result 3: %s\n", result_3->access_token.type);
}

void validate_delegated_action_fun(CLIENT *clnt) {
	struct ser_response  *result_4;
	struct cl_request  validate_delegated_action_1_arg;

	struct tokken empty_token;
	empty_token.type = "";

	validate_delegated_action_1_arg.client_id = "4";
	validate_delegated_action_1_arg.tokken = empty_token;

	result_4 = validate_delegated_action_1(&validate_delegated_action_1_arg, clnt);
	if (result_4 == (struct ser_response *) NULL) {
		clnt_perror (clnt, "call failed");
	}

	printf("Result 4: %s\n", result_4->access_token.type);
}

void process_request_cmd(CLIENT *clnt, std::string client_id,
							std::string auto_refresh) {

	std::cout << "Request command\n";

	// Does the current user have auto_refresh enabled?
	if (auto_refresh == "1") {
		user_refresh[client_id] = true;
	} else {
		user_refresh[client_id] = false;
	}

	// O-Auth scheme
}

void process_other_cmd(CLIENT *clnt, std::string client_id,
						std::string command, std::string resource) {

	std::cout << "Command:" << command << std::endl;
}


int main (int argc, char *argv[])
{
	char *host;
	if (argc < 3) {
		printf ("usage: %s server_host\n", argv[0]);
		exit (1);
	}

	host = argv[1];
	CLIENT *clnt = clnt_create (host, OAUTH_PROG, OAUTH_VERS, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}

	char *client_file;
	client_file = argv[2];

	// Read from client file
	std::ifstream clients(client_file);
	std::string command;
	while(std::getline(clients, command)) {
		std::stringstream ss(command);
		std::vector<std::string> command_parts;
		while(ss.good()) {
			std::string substr;
			std::getline(ss, substr, ',');
			command_parts.push_back(substr);
		}

		if (command_parts[1] == "REQUEST") {
			process_request_cmd(clnt, command_parts[0], command_parts[2]);
		} else {
			process_other_cmd(clnt, command_parts[0], command_parts[1], command_parts[2]);
		}
	}


	// O-Auth scheme
	// request_autorization_fun(clnt);
	// request_access(clnt);
	// request_access(clnt);
	// validate_delegated_action_fun(clnt);

	clnt_destroy (clnt);
	exit (0);
}
