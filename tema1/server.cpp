/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "oauth.h"
#include "helpers_server.h"
#include "token.h"

char *string_to_char(std::string str) {
	char *cstr = (char *)calloc(str.length() + 1, sizeof(char));
	strcpy(cstr, str.c_str());
	return cstr;
}

struct tokken create_empty_token() {
	struct tokken new_token;
	new_token.approved = 0;
	new_token.type = "Empty token";
	new_token.value = "";
	new_token.ttl = 0;
	return new_token;
}

struct tokken create_token(int approved,
							std::string type,
							std::string initial_value,
							int ttl = 0) {

	struct tokken new_token;

	char *token_value = generate_access_token(string_to_char(initial_value));

	new_token.approved = approved;
	new_token.type = string_to_char(type);
	new_token.value = strdup(token_value);
	new_token.ttl = ttl;

	return new_token;
}

// TODO: get server output from here
struct ser_response *
request_autorization_1_svc(struct cl_request *argp, struct svc_req *rqstp)
{
	static struct ser_response  result;
	std::cout << "BEGIN " << argp->client_id << " AUTHZ" << std::endl;

	// Default tokens
	result.auto_token = create_empty_token();
	result.access_token = create_empty_token();
	result.refresh_token = create_empty_token();

	// Search the user in the database
	std::string user_id = argp->client_id;
	if (users.find(user_id) == users.end()) {
		result.message =  "USER_NOT_FOUND";
		return &result;
	}
	
	result.auto_token = create_token(0, "auto_token", user_id, 0);
	result.message = "USER_FOUND";


	std::cout << "  RequestToken = " << result.auto_token.value << std::endl;

	return &result;
}

// TODO: get server output from here
struct ser_response *
request_approve_1_svc(struct cl_request *argp, struct svc_req *rqstp)
{
	static struct ser_response  result;

	// Default tokens
	result.access_token = create_empty_token();
	result.refresh_token = create_empty_token();
	int user_index = argp->user_index;
	
	// Check if the user has been authorized
	std::unordered_map<std::string, std::string> permissions;
	std::string out = parse_permissions(user_index, permissions);

	// No permissions granted
	if (out == "DENIED") {
		result.message = "Not approved";
		result.auto_token = argp->tokken;
		return &result;
	}

	// Permissions granted - sign the token
	argp->tokken.approved = 1;
	result.auto_token = argp->tokken;
	result.message = "Approved";

	return &result;
}

struct ser_response *
request_access_token_1_svc(struct cl_request *argp, struct svc_req *rqstp)
{
	static struct ser_response  result;

	// Check if the autorization token is valid
	if (argp->tokken.approved == 0) {
		result.message = "REQUEST_DENIED";
		result.auto_token = argp->tokken;
		result.access_token = create_empty_token();
		result.refresh_token = create_empty_token();
		
		return &result;
	}

	// Generate access token
	result.access_token = create_token(0, "access_token", argp->tokken.value, token_availability);
	std::cout << "  AccessToken = " << result.access_token.value << std::endl;
	user_access_token[argp->client_id] = result.access_token.value;
	

	// Attach permissions to the access token
	std::unordered_map<std::string, std::string> permissions;
	parse_permissions(argp->user_index, permissions);
	token_perm[result.access_token.value] = permissions;

	// Generate refresh token
	if (std::string(argp->info) == "REFRESH") {
		result.refresh_token = create_token(0, "refresh_token", result.access_token.value, token_availability);
		std::cout << "  RefreshToken = " << result.refresh_token.value << std::endl;
	} else {
		result.refresh_token = create_empty_token();
	}

	result.message = "ACCESS_GRANTED";
	result.auto_token = argp->tokken;

	return &result;
}

struct ser_response *
validate_delegated_action_1_svc(struct cl_request *argp, struct svc_req *rqstp)
{
	// Prepare the default response from server
	static struct ser_response  result;
	result.message = "VALIDATE_DELEGATED_ACTION";
	result.auto_token = create_empty_token();
	result.access_token = create_empty_token();
	result.refresh_token = create_empty_token();

	// Extract access token, user_id, resource and command from request
	struct tokken access_token = argp->tokken;
	std::string user_id = argp->client_id;
	std::stringstream ss(argp->info);
	std::vector<std::string> parts;

	while (ss.good()) {
		std::string substr;
		std::getline(ss, substr, ',');
		parts.push_back(substr);
	}
	std::string command = parts[0];
	std::string resource = parts[1];

	// The resource is not available in the database
	if (resources.find(resource) == resources.end()) {
		result.message = "RESOURCE_NOT_FOUND";
		return &result;
	}

	// The resource is not available for the current access token
	std::unordered_map<std::string, std::string> tok_perm = token_perm[access_token.value];
	std::string res_perm = tok_perm[resource];
	char first_letter = command[0];
	bool found = res_perm.find(first_letter) != std::string::npos;

	if (found == false) {
		result.message = "OPERATION_NOT_PERMITTED";
		return &result;
	}

	result.message = "PERMISSION_GRANTED";
	return &result;
}

struct ser_response *
refresh_access_token_1_svc(struct cl_request *argp, struct svc_req *rqstp)
{
	static struct ser_response  result;

	std::string refresh_token = argp->tokken.value;
	std::string access_token = user_access_token[argp->client_id];

	// Generate new access token based on the refresh token
	struct tokken new_access_token = create_token(0, "access_token",
													refresh_token, token_availability);

	// Update the access token in the database
	user_access_token[argp->client_id] = new_access_token.value;

	// Update the permissions associated with the new access token
	token_perm[new_access_token.value] = token_perm[access_token];
	token_perm.erase(access_token);

	// Genereate new refresh token
	struct tokken new_refresh_token = create_token(0, "refresh_token",
											new_access_token.value, token_availability);

	// Return tthe response to the client
	result.message = "ACCESS_GRANTED";
	result.auto_token = create_empty_token();
	result.access_token = new_access_token;
	result.refresh_token = new_refresh_token;

	return &result;
}
