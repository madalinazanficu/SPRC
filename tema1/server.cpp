/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "oauth.h"
#include "helpers_server.h"
#include "token.h"


char *string_to_char(std::string str) {
	char *cstr = (char *)calloc(str.length() + 1, sizeof(char));
	strcpy(cstr, str.c_str());
	return cstr;
}


// Create an empty token for the default response
struct tokken create_empty_token() {
	struct tokken new_token;
	new_token.approved = 0;
	new_token.type = string_to_char("Empty token");
	new_token.value = string_to_char("");
	new_token.ttl = 0;
	return new_token;
}


// Create a generic token with the given parameters
struct tokken create_token(int approved,
							std::string type,
							std::string initial_value,
							int ttl = 0) {

	struct tokken new_token;

	char *token_value = generate_access_token(string_to_char(initial_value));

	new_token.approved = approved;
	new_token.type = string_to_char(type);
	new_token.value = strdup(token_value);
	new_token.ttl = ttl;

	return new_token;
}


/*
	The server receives an authorization request from the client.
	It searches if the user exists in the database.
*/
struct ser_response *
request_autorization_1_svc(struct cl_request *argp, struct svc_req *rqstp)
{
	static struct ser_response  result;
	std::cout << "BEGIN " << argp->client_id << " AUTHZ" << std::endl;

	// Default tokens
	result.auto_token = create_empty_token();
	result.access_token = create_empty_token();
	result.refresh_token = create_empty_token();

	// Search the user in the database
	std::string user_id = argp->client_id;
	if (users.find(user_id) == users.end()) {
		result.message =  string_to_char("USER_NOT_FOUND");
		return &result;
	}
	
	result.auto_token = create_token(0, "auto_token", user_id, 0);
	result.message = string_to_char("USER_FOUND");


	std::cout << "  RequestToken = " << result.auto_token.value << std::endl;

	return &result;
}


/*
	The server receives an approval request from the client.
	It uses the permissions parsed from the database and authorizes
	specific operations for the client.
*/

struct ser_response *
request_approve_1_svc(struct cl_request *argp, struct svc_req *rqstp)
{
	static struct ser_response  result;

	// Default tokens
	result.access_token = create_empty_token();
	result.refresh_token = create_empty_token();
	int user_index = argp->user_index;
	
	// Check if the user has been authorized
	std::unordered_map<std::string, std::string> permissions;
	std::string out = parse_permissions(user_index, permissions);

	// No permissions granted
	if (out == "DENIED") {
		result.message = string_to_char("Not approved");
		result.auto_token = argp->tokken;
		return &result;
	}

	// Permissions granted - sign the token
	argp->tokken.approved = 1;
	result.auto_token = argp->tokken;
	result.message = string_to_char("Approved");

	return &result;
}


struct ser_response *
request_access_token_1_svc(struct cl_request *argp, struct svc_req *rqstp)
{
	static struct ser_response  result;

	// Check if the autorization token is valid
	if (argp->tokken.approved == 0) {
		result.message = string_to_char("REQUEST_DENIED");
		result.auto_token = argp->tokken;
		result.access_token = create_empty_token();
		result.refresh_token = create_empty_token();
		
		return &result;
	}

	// Generate access token
	result.access_token = create_token(0, "access_token", argp->tokken.value,
										token_availability);
	access_tokens[argp->client_id] = result.access_token.value;
	user_ttl[argp->client_id] = result.access_token.ttl;
	std::cout << "  AccessToken = " << result.access_token.value << std::endl;


	// Attach permissions to the access token
	std::unordered_map<std::string, std::string> permissions;
	parse_permissions(argp->user_index, permissions);
	token_perm[result.access_token.value] = permissions;

	// Generate refresh token
	if (std::string(argp->info) == "REFRESH") {
		result.refresh_token = create_token(0, "refresh_token",
								result.access_token.value, token_availability);
		refresh_tokens[argp->client_id] = result.refresh_token.value;
		std::cout << "  RefreshToken = " << result.refresh_token.value << std::endl;
	} else {
		result.refresh_token = create_empty_token();
	}

	result.message = string_to_char("ACCESS_GRANTED");
	result.auto_token = argp->tokken;

	return &result;
}


/*
	The client wants to execute a command on a resource.
	The server check if the client has all the permissions to perform.
*/
struct ser_response *
validate_delegated_action_1_svc(struct cl_request *argp, struct svc_req *rqstp)
{
	// Prepare the default response from server
	static struct ser_response  result;
	result.auto_token = create_empty_token();
	result.access_token = create_empty_token();
	result.refresh_token = create_empty_token();
	result.message = string_to_char("");

	// Extract access token, user_id, resource and command from request
	std::string user_id = argp->client_id;
	std::string acc_token = access_tokens[user_id];

	// One command was executed
	user_ttl[user_id] = user_ttl[user_id] - 1;
	int ttl = user_ttl[user_id];

	// Extract command and resource from the request
	std::stringstream ss(argp->info);
	std::vector<std::string> parts;

	while (ss.good()) {
		std::string substr;
		std::getline(ss, substr, ',');
		parts.push_back(substr);
	}
	std::string command = parts[0];
	std::string resource = parts[1];

	std::string error_message = "DENY (" + command + "," + resource+ ","
				+ acc_token + "," + std::to_string(ttl) + ")";

	// The resource is not available in the database
	if (resources.find(resource) == resources.end()) {
		std::cout << error_message << std::endl;
		result.message = string_to_char("RESOURCE_NOT_FOUND");
		return &result;
	}

	// The resource is not available for the current access token
	std::unordered_map<std::string, std::string> tok_perm = token_perm[acc_token];
	std::string res_perm = tok_perm[resource];
	char first_letter = command[0];
	if (command == "EXECUTE")
		first_letter = 'X';

	bool found = res_perm.find(first_letter) != std::string::npos;

	if (found == false) {
		std::cout << error_message << std::endl;
		result.message = string_to_char("OPERATION_NOT_PERMITTED");
		return &result;
	}

	std::cout << "PERMIT (" << command << "," << resource << ","
				<< acc_token  << "," << ttl << ")" << std::endl;

	result.message = string_to_char("PERMISSION_GRANTED");
	return &result;
}


/*
	The client may be able to refresh the access token.
	In this case, the server generates a new access token and
	a new refresh token.
*/
struct ser_response *
refresh_access_token_1_svc(struct cl_request *argp, struct svc_req *rqstp)
{
	
	// Default response
	static struct ser_response  result;
	result.message = string_to_char("");
	result.auto_token = create_empty_token();
	result.access_token = create_empty_token();
	result.refresh_token = create_empty_token();

	// Extract command and resource from the request
	std::string user_id = argp->client_id;
	std::stringstream ss(argp->info);
	std::vector<std::string> parts;

	while (ss.good()) {
		std::string substr;
		std::getline(ss, substr, ',');
		parts.push_back(substr);
	}
	std::string command = parts[0];
	std::string resource = parts[1];
	std::string error_message = "DENY (" + command + "," + resource + ",,0)";

	// Get tokens from the database		
	std::string acc_token = access_tokens[user_id];
	std::string ref_token = refresh_tokens[user_id];
	int ttl = user_ttl[user_id];


	// Check if the access token is valid
	if (acc_token == "") {
		std::cout << error_message << std::endl;
		result.message = string_to_char("PERMISSION_DENIED");
		return &result;
	}

	// Check refresh condition
	if (ttl == 0) {
		if (ref_token == "") {
			std::cout << error_message << std::endl;
			result.message = string_to_char("TOKEN_EXPIRED");
			return &result;
		}

		// Generate new access token based on the refresh token
		struct tokken new_access_token = create_token(0, "access_token",
												ref_token, token_availability);

		// Update the permissions associated with the new access token
		token_perm[new_access_token.value] = token_perm[acc_token];
		token_perm.erase(acc_token);

		// Genereate new refresh token
		struct tokken new_refresh_token = create_token(0, "refresh_token",
										new_access_token.value, token_availability);
		
	
		// Save the tokens in the database
		access_tokens[argp->client_id] = new_access_token.value;
		refresh_tokens[argp->client_id] = new_refresh_token.value;
		user_ttl[argp->client_id] = new_access_token.ttl;

		// Return the response to the client
		result.message = string_to_char("TOKEN_REFRESHED");
		result.access_token = new_access_token;
		result.refresh_token = new_refresh_token;

		std::cout << "BEGIN " << argp->client_id << " AUTHZ REFRESH" << std::endl;
		std::cout << "  AccessToken = " << new_access_token.value << std::endl;
		std::cout << "  RefreshToken = " << new_refresh_token.value << std::endl;
	}


	return &result;
}
